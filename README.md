# rt.el : The run target package for Emacs.

This packages allows to list the available run target generated by a cmake project and exec them from emacs.
It uses cmake-ide and cmake to generate a cbp file (i.e. CodeBlocks project) and use it to get the availble executable generated by the compile process. 
Then all executable can be run from emacs. 

This package is an to be used as an extension to [cmake-ide](https://github.com/atilaneves/cmake-ide).

# Usage
Add
```lisp
(require 'rt)
``` 
in your `.emacs.el`, *after* including `cmake-ide` because one function of `cmake-ide` is redefined in `rt`

Then launch `rt-exec` and use completion to get the list of executables.

# Usefull config

I add the following to my `.emacs.el` to ease the use of `cmake-ide` and `rt`. It allows quick build in release or debug and bind rt-exec to a key contol seq.

```lisp
(defun set-cmake-opts-build-type (mode)
  "Switch compile option in 'cmake-ide-cmake-opts to MODE (i.e Debug, Release, RelWithDebInfo)."
  (interactive)
  (let ((opts cmake-ide-cmake-opts))
    
    (let* ((opts-list (split-string opts))
	   (clean (delq nil (mapcar (function (lambda (x) (if (string-match-p "CMAKE_BUILD_TYPE" x) 'nil x))) opts-list))))
      (setq cmake-ide-cmake-opts
	    (concat (mapconcat 'identity clean " ")  "-DCMAKE_BUILD_TYPE=" mode)))))
	    

(defun compile-in-release ()
  "Set compil flag and run."
  (interactive)
  (progn
    (let ((comp-proc (get-buffer-process (current-buffer))))
      (if comp-proc
          (if (or (not (eq (process-status comp-proc) 'run))
                  (eq (process-query-on-exit-flag comp-proc) nil)
		  (progn
                    (interrupt-process comp-proc)
                    (sit-for 1)
                    (delete-process comp-proc))
		  ))))    
    (set-cmake-opts-build-type "Release")
    (cmake-ide-run-cmake)    
    (if (file-exists-p (expand-file-name "compile_commands.json" (projectile-project-root)))
	(delete-file (expand-file-name "compile_commands.json" (projectile-project-root)))
      )
    (make-symbolic-link (expand-file-name "compile_commands.json" (cide--build-dir)) (projectile-project-root))
    (let ((cmake-process (get-process "cmake")))
      (if cmake-process
	  (set-process-sentinel (get-process "cmake")
				(lambda (_process _event)
				  (cmake-ide-compile)))
	(cmake-ide-compile)))))

(defun compile-in-debug ()
  "Set compil flag and run."
  (interactive)
  (progn
    (let ((comp-proc (get-buffer-process (current-buffer))))
      (if comp-proc
          (if (or (not (eq (process-status comp-proc) 'run))
                  (eq (process-query-on-exit-flag comp-proc) nil)
		  (progn
                    (interrupt-process comp-proc)
                    (sit-for 1)
                    (delete-process comp-proc))
		  ))))    
    (set-cmake-opts-build-type "Debug")
    (cmake-ide-run-cmake)
    (if (file-exists-p (expand-file-name "compile_commands.json" (projectile-project-root)))
	(delete-file (expand-file-name "compile_commands.json" (projectile-project-root)))
      )
    (make-symbolic-link (expand-file-name "compile_commands.json" (cide--build-dir)) (projectile-project-root))
    (let ((cmake-process (get-process "cmake")))
      (if cmake-process
	    (set-process-sentinel (get-process "cmake")
				  (lambda (_process _event)
				    (cmake-ide-compile)))
	  (cmake-ide-compile)
  ))))

(global-set-key [f6]    'compile-in-debug)
(global-set-key [f7]    'compile-in-release)
(global-set-key [f9]    'cmake-ide-compile)
(global-set-key [M-f9]  'kill-compilation)
(global-set-key [f8]    'next-error)
(global-set-key [f10]   'rt-exec)
(global-set-key [C-f10] 'rt-exec-debug)
(setq gdb-many-windows 't)
```
